*
* Created by: Chang Man Wai, 2004
* useful sites: http://www.lexiconer.com/
*
* 06SEP2008 : close canton.dbf as soon as possible
* 04NOV2008 : prevent clearing the clipboard when hitting reset
* 30JAN2009 : show touched, use fixed width font in listbox
* 01FEB2009 : Double-click to email, add text1.interactivechange()
* 03APR009 : Change button "NewLine" to "History",  add property buffer to class MyForm,
*       pressing it would recall all outputed Chinese Big5 and then the buffer be cleared
*       hitting cmdReset would also remember the history
* 13APR2009: Make cmdClip to remember history as well (like cmdReset)
* 10MAY2009: handle adnormal shutdown via "ON SHUTDOWN" and ReleaseType
* 24AUG2009: smarter buffer handling for cmdClip, cmdHistory and cmdReset
* 24SEP2009: show all possible keys text1 is empty
* 15OCT2009: bugfix for text1.valid() when handling blank key input
* 11NOV2009: smarter handling in thisform.text1.interactivechange()
* 20NOV2009: highlight text1 when mouse clicked it via gotfocus()
* 15APR2010: use form.BorderStyle to ensure minimum width & height
* 27MAY2010:  thisform.text1 now accepts only letters
* 17DEC2010: add DEFAULT_CLIPTEXT to faciliate Thunderbird message forwarding,
*	bugfix for the 3 buttons in response to buffer changes, bugfix to SingleInstance()
* 18DEC2010: bugfix for FirstInstance(), add CloseMutex(), add getGUID()
* 10FEB2011: use sysmetric() to find out Window$ desktop size
* 19APR2011: hide the start-up screen by pushing & popping _screen.top and _screen.windowstate
* 25APR2011: discard _screen.old_top
* 07JUL2011: Add checkbox chkOnTop to control Always On Top
* 03SEP2011: Save clipboard when program starts
* 17OCT2011: Better icons: chang32.ico and chang256.ico using IcoFX-1.6.4
* 22OCT2011: If system clipboard is empty, set it to DEFAULT_CLIPTEXT (to save some clicks)
*	bugfix for "WAIT  WINDOW" after  calling  FirstInstance(); clean  up start-up codes
* 23NOV2011: bugfix for Mutex
* 11MAR2012: Add function pastebig5() after nearly 24 hours of using Google and Usenet!
* 			 Remember to Sleep() a while for SetForegroundWindow() to activate the caret
* 14MAR2012: Add chkDirect to control whether to use pastebig5()
* 22JAN2013: Add PageFrame; Beautify interface
* 27JAN2013: Support List1.DblClick(); Add cmdClear next to Text1; Fix bug in text1.Format;
* 				Re-coded text1.valid() based on text1.interactivechange();
*				Add WasHit to MyCommandButton; Coupled Text1,cmdClear,cmdClip,cmdHistory,cmdReset 
*					using event sequence and MyCommandButton.WasHit
* 01FEB2013: Various bugfixes and simplification of codes
* 02FEB2013: toquit is now char(1); button.washit was set in button.when()
* 11FEB2013: change TabStyle of PageFrame
* 12FEB2013: add cmdWebsite; re-coded mailto() as BrowseTo()
* 20OCT2013: consider position of taskbar when showing this program
* 10FEB2014: fill in form.tooltiptext
* 10APR2014: Add class MyUnicodeTextBox from Textbox of Micro$oft Forms 2.0 ActiveX objects
*            Disable error when canton.dbf cannot be updated (in Win 7 or above)
* 29AUG2014: add btnReturn to frmQuit, add UnicodeToString() and StringToUnicode()
*            testing M$ Forms textbox controls (setting multiline during init)
*            add Page4 to pageframe, change some BackColors,
*            change class of edit1 from EditBox to MyUnicodeTextbox, 
*            MyUnicodeCodeTextbox has no Valid() event but LostFocus()
* 30AUG2014: database change: THEKEY's lengeth increased
*			 Add WideCharToMultiByte() and MultiByteToWideChar()
* 08SEP2014: Add CopyUnicode2Clipboard() to replace _cliptext
*			 Add Page3 to PageFrame1
* 09SEP2014: making progress in handling Unicode and UTF8 via VFP 9
*			 Unicode using functions: sys(3101), strconv()
*			 add uncd c(4) to canton.dbf, to store unicode using base64 encoding strconv(13)
*            increase the length of column big5 from 2 to 4
*			 add recode() which convert big5(dbcs) -> UT8 -> base64 string
* 13SEP2014: make DEFAULT_CLIPTEXT a global variable rather than a #define
* 14SEP2014: Add Unicode characters from CJ-HKSCS-2008.txt, update field Changjie
*            Add functions FromBase64() and ToBase64()
* 15SEP2014: Add tbsave(), tbrest(); ToBase64() output different from strconv(13)
*			 Add variable _screen.cantondbf and detection logic for canton.dbf
* 16SEP2014: Add index on column THEKEY
* 18SEP2014: Add error-checking in cmdUpdate.click() when modifying canton.dbf
*			 Move readcanton(), readoldcanton() & readchangjei ouf of MyForm
*			 Add readhkscs2008()
* 12OCT2014: Add VFP6CopyUnicode() as workaround in VFP 6 to 
* 			 pass Unicode characters to ActiveX controls via clipboard
* 16OCT2014: Add VFP6EncodeUTF8() as workaround in VFP6 to Base64-encode UTF8-8
*            Found paste.exe and clip.exe from 
*                   http://www.c3scripts.com/tutorials/msdos/paste.html
*                   http://www.c3scripts.com/tutorials/msdos/clip.html
* 17OCT2014: Add LaunchExeAndWait() to replace WinExecute()
*    
*
* Useful links: 
* http://input.foruto.com/cie/cie_bd.htm
* http://fox.wikis.com/wc.dll?Wiki~SkipValidOnExit
* VFP 9 Runtime installer
* http://www.foxpert.com/runtime.htm
*
#undef debug_caret

#define GW_HWNDNEXT 2

#DEFINE GUITHREADINFO_SIZE  48

#DEFINE GUI_CARETBLINKING  1
#DEFINE GUI_INMOVESIZE     2
#DEFINE GUI_INMENUMODE     4
#DEFINE GUI_SYSTEMMENUMODE 8
#DEFINE GUI_POPUPMENUMODE  16

#define KEYEVENTF_KEYUP  0x0002 

#define WM_CHAR            0x0102
#define WM_SETTEXT         0x000C
#define WM_PASTE           0x0302

#DEFINE CRYPT_STRING_BASE64 0x0001
#DEFINE CRYPT_STRING_NOCRLF 0x40000000
#DEFINE CRYPT_STRING_NOCR 0x80000000

#define VK_CONTROL		   0x11

*
* WinExecute() from http://www.news2news.com/vfp/?example=2
*
#DEFINE SW_HIDE 0
#DEFINE SW_SHOWNORMAL 1
#DEFINE SW_SHOWMINIMIZED 2
#DEFINE SW_SHOWMAXIMIZED 3
#DEFINE SW_SHOWNOACTIVATE 4
#DEFINE SW_SHOW 5
#DEFINE SW_MINIMIZE 6
#DEFINE SW_SHOWMINNOACTIVE 7
#DEFINE SW_SHOWNA 8
#DEFINE SW_RESTORE 9
#DEFINE SW_SHOWDEFAULT 10

#Define K_F1 28
#Define K_ESC 27
#Define K_ENTER 13
#define K_LF 10
#define K_TAB 9

#define MUTEX_NAME "chang_canton"
#define APP_NAME  "Cantonese Input for Chang"
#define ERROR_MUTEX_EXISTS 183

parameters m.p1, m.p2

clear all
close all

set resource off

local g_Form
public DEFAULT_CLIPTEXT

with _screen
	.AddProperty("old_top", _screen.top)
	.top=-2*sysmetric(2)

	.AddProperty("StartUpFolder", fullpath(curdir()))
	.AddProperty("Quit", .f.)
	.AddProperty("MutexHandle", -1)
	.AddProperty("old_winstate", _screen.WindowState)

	.AddProperty("min_height", 280)
	.AddProperty("min_width", 440)
	.AddProperty("FormInit", .f.)
	.AddProperty("cantondbf",fullpath(curdir())+"data\canton.dbf")
	.AddProperty("clipbatname",UniqueFname("bat"))
	.AddProperty("encdbatname",UniqueFname("bat"))
	.AddProperty("txtname", UniqueFname("txt"))
	.AddProperty("outname", UniqueFname("txt"))
endwith

* check existence of canton.dbf, abort if missing
do case
	case file(_screen.cantondbf)
		* data folder under current directory (preferred)
	case file(fullpath(curdir())+"canton.dbf")
		* current directory
		_screen.cantondbf=fullpath(curdir())+"canton.dbf"
	otherwise
		messagebox("missing "+_screen.cantondbf, 16)
		return
endcase

if left(version(4),2)>"06"
	Sys(3101,65001)
	sys(987,.f.)
else
	sys(3005,65001)
endif

tbsave()

_screen.ShowTips=.t.
_screen.Enabled=.f.
if left(version(4),2)>"06"
	_screen.themes=.f.
endif

Set Exact On
Set Escape Off
set help off
Set Talk Off
Set Notify Off
Set Safety Off

if _vfp.StartMode=4
	set debug off
endif

ON ERROR DO errhand WITH ;
	ERROR( ), MESSAGE( ), MESSAGE(1), PROGRAM( ), LINENO( )

set console off

set alternate to (_screen.clipbatname)
set alternate on
?? "echo off"
?
?? "chcp 65001"
?
?? "clip < "+_screen.txtname
set alternate off
set alternate to

set alternate to (_screen.encdbatname)
set alternate on
?? "echo off"
?
?? "chcp 65001"
?
?? "paste | b64 -e > "+_screen.outname
set alternate off
set alternate to

set console on

if left(version(4),2)>"06"
	* UTF-8 string base64 encoded
	DEFAULT_CLIPTEXT=strconv("44CQ6L2J6LK844CR",14)
	CopyUnicodeText2Clipboard(DEFAULT_CLIPTEXT)
else
	DEFAULT_CLIPTEXT=FromBase64("44CQ6L2J6LK844CR")
	VFP6CopyUnicode(DEFAULT_CLIPTEXT)
endif

if  FirstInstance(MUTEX_NAME)
	on shutdown do myquit
	_screen.quit=.f.
	g_form=Createobject("myform")
	If Type("g_form")="O"
		Set Sysmenu To _Msm_edit
		g_form.Show()
		Read Events
		Set Sysmenu To Default
	Endif
	CloseMutex()
	on shutdown
else
	messagebox("Only One Instance!",16)
endif

_screen.top=_screen.old_top
_screen.WindowState=_screen.old_winstate
_screen.enabled=.t.

delete file (_screen.clipbatname)
delete file (_screen.encdbatname)
delete file (_screen.txtname)
delete file (_screen.outname)

Set Escape On
Set Talk On
Set Notify On
Set Safety On
set debug on
set help on

* must be executed before CLEAR ALL
tbrest()

clear all
release all

If _screen.quit
	Quit
Endif

on error *
set resource on
on error
Return

PROCEDURE errhand
LPARAMETER merror, mess1, mess2, mprog, mlineno

set console off
set alternate to (_screen.StartUpFolder+"canton_err.txt") additive
set alternate on

? repl("*",10), date(), time()
? 'Error number: ' + LTRIM(STR(merror))
? 'Error message: ' + mess1
? 'Line of code with error: ' + mess2
? 'Line number of error: ' + LTRIM(STR(mlineno))
? 'Program with error: ' + mprog
? repl("*",10)

set alternate off
set alternate to
set console on
return

procedure myquit
	local xx
	on error *
	on shutdown
	close all
	xx=sys(2023)+"\*.tmp"
	if _screen.quit
		delete files &xx
	endif
	on error
	quit
return

Define Class MyLabel As Label
	AutoSize=.t.
	FontName="Courier New"
	FontSize=14
	BackStyle=0
	IntegralHeight=.t.
	Caption=""
Enddefine

Define Class MyCommandButton As CommandButton
	Height=30
	Width=120
	TabStop=.F.
	FontSize=12
	FontBold=.t.
	BackColor=RGB(192,192,192)
	Cancel=.f.
	WasHit=.f.

	Procedure When()
		this.WasHit=.t.
	Return
Enddefine

Define class MyPage2 as MyPage
	caption="\<Settings"
	
	Add Object chkDirect As checkbox with ;
		top=40, Left=15, Fontsize=12, AutoSize=.t., ;
		Caption="Send Key To Previous Window", Value=.f.
	Add Object chkOnTop As checkbox with ;
		top=80, Left=15, FontSize=12, AutoSize=.t., ;
		Caption="Always On Top", value=.f.
	Add Object chkBig5Only As checkbox with ;
		top=120, Left=15, FontSize=12, AutoSize=.t., ;
		Caption="Big5 Characters Only", value=.f.

	Function chkOnTop.interactivechange()
		ThisForm.AlwaysOnTop=this.value
	Return .t.
EndDefine

Define class MyPage3 as MyPage
	caption="\<Update"
	enabled=left(version(4),2)="09"	
	enabled=.t.

	Add object lblText21 as MyLabel with ;
		top=15, left=5, caption="UTF-8", fontsize=9
	Add object lblText22 as MyLabel with ;
		top=15, left=55, caption="Big5", fontsize=9
	Add object lblText23 as MyLabel with ;
		top=15, left=125, caption="THEKEY", fontsize=9
	Add object lblText24 as MYLabel with ;
		top=15, left=230, caption="Changjei", fontsize=9
	Add object lblText25 as MyLabel with ;
		top=15, left=330, caption="Touched", fontsize=9

	Add Object text21 as MyUnicodeTextbox with ;
		top=35, left=5, ;
		Height=30, width=40, Autosize=.t.
	Add Object text22 as MyUnicodeTextbox with ;
		top=35, left=55, ;
		Height=30, width=60
	Add Object text23 as MyTextbox with ;
		top=32, left=125, ;
		Height=30, width=100, value="", format="@"
	Add Object text24 as MyTextbox with ;
		top=32, left=230, ;
		Height=30, width=95, value="", format="@"
	Add Object text25 as MyTextbox with ;
		top=32, left=330, ;
		Height=30, width=80, value="", format=""
	Add Object cmdSearch as MyCommandButton with ;
		top=75, left=5, caption="\<Search"
	Add Object cmdUpdate as MyCommandButton with ;
		top=75, left=140, caption="\<Add", visible=.f.

	Add object lblText11 as MyLabel with ;
		top=120, left=5, caption="UTF-8", fontsize=9
	Add Object text11 as MyUnicodeTextbox with ;
		top=138, left=5, ;
		Height=30, width=40, Autosize=.t.
	Add Object cmdTranscode as MyCommandButton with ;
		top=138, left=50, caption="\<Transcode"
	Add object lblText12 as MyLabel with ;
		top=120, left=180, caption="Base64", fontsize=9
	Add Object text12 as MyTextbox with ;
		top=138, left=180, ;
		Height=30, width=100, value="", format="K"

	Add object lblMessage as MyLabel with ;
		top=215, left=5, caption="", forecolor=rgb(255,0,0), fontsize=12, fontbold=.t.

	procedure cmdSearch.click()
		local m.uncd
		if this.caption="\<Cancel"
			this.caption="\<Search"
			with this.parent
				.text21.text=""
				.text22.text=""
				.text23.value=""
				.text24.value=""
				.text25.value=0
				.cmdUpdate.visible=.f.
				.lblMessage.caption=""
				.text11.text=""
				.text12.value=""
			endwith
		else
			with this.parent
				if empty(.text21.text)
					.lblMessage.caption="No UTF-8 character to search!"
					return
				endif
				if left(version(4),2)>"06"
					m.uncd=strconv(alltrim(.text21.text),13)
				else
					* m.uncd=ToBase64(alltrim(.text21.text))
					.text21.copy()
					m.uncd=VFP6EncodeUTF8()
				endif
				.text12.value=m.uncd
				select 0
				use (_screen.cantondbf) noupdate
				locate for uncd=m.uncd
				if found()
					.text22.text=alltrim(canton.big5)
					.text23.value=canton.thekey
					.text24.value=canton.changjei
					.text25.value=canton.touched
					.cmdUpdate.caption="\<Update"
					.text11.text=.text21.text
					.cmdTranscode.click()
				else
					.text22.text=.text21.text
					.lblMessage.caption="Unicode character not found!"
					.cmdUpdate.caption="\<Add"
				endif
				.cmdUpdate.visible=.t.
				use
			endwith
			this.caption="\<Cancel"
		endif
	return

	procedure cmdUpdate.click()
		local m.big5, m.uncd, m.thekey, m.changjei, m.touched
		local m.errhand
		with this.parent
			if left(version(4),2)>"06"
				m.uncd=strconv(alltrim(.text21.text),13)
				m.big5=strconv(alltrim(.text22.text),11)
			else
				.text21.copy()
				m.uncd=VFP6EncodeUTF8()
				m.big5=.text22.text
			endif
			m.thekey=alltrim(.text23.value)
			m.changjei=alltrim(.text24.value)
			m.touched=.text25.value

			m.errhand=on("error")
			on error *
			select 0
			use (_screen.cantondbf) shared
			locate for uncd=m.uncd
			if found()
				select canton
				replace big5 with m.big5
				replace thekey with m.thekey
				replace changjei with m.changjei
				replace touched with m.touched
				.lblMessage.caption="UTF-8 character updated!"
			else
				insert into canton ( ;
					uncd, thekey, big5, changjei, touched ;
				) values ( ;
					m.uncd, m.thekey, m.big5, m.changjei, m.touched ;
				)
				.lblMessage.caption="UTF-8 character added!"
			endif
			use
			on error &errhand
			.text21.text=""
			.text22.text=""
			.text24.value=""
			.text25.value=0
			.cmdUpdate.visible=.f.
			.cmdUpdate.caption="\<Add"
			.cmdSearch.caption="\<Search"
		endwith
	endproc

	procedure cmdTranscode.click()
		with this.parent
			do case
				case empty(.text11.text) and empty(.text12.value)
					.lblMessage.caption="Fill in UTF-8 or Base64 to transcode!"
				case empty(.text11.text)
					if left(version(4),2)>"06"
						.text11.text=strconv(.text12.value,14)						
						.text21.text=.text11.text
					else
						VFP6CopyUnicode(FromBase64(.text12.value))
						.text11.paste()
						.text21.text=""
						.text21.paste()
					endif
				case empty(.text12.value)
					if left(version(4),2)>"06"
						.text12.value=strconv(.text11.text,13)
						.text21.text=.text11.text
					else
						* .text12.value=ToBase64(.text11.text)
						.text11.copy()
						.text12.value=VFP6EncodeUTF8()
						.text21.text=""
						.text21.paste()
					endif
				otherwise
					.text11.text=""
					.text12.value=""
			endcase
		endwith
	return
EndDefine

Define class MyPage4 as MyPage
	caption="\<About"
	* BackColor=RGB(199,157,83)

	Add Object lblCantonDBF As EditBox With ;
		top=80, Left=15, Fontsize=10, Width=400, Height=50, ;
		Scrollbars=0, Fontname="Courier New", Value="Data: "+_screen.cantondbf
	Add Object lblBig5 As Label With ;
		top=130, Left=15, FontSize=10, FontItalic=.t., FontBold=.t., ;
		AutoSize=.t., ForeColor=rgb(255,64,64), ;
		Caption=iif(left(version(4),2)=="06","NOTE: This program uses Big5 charset NOT Unicode!","")
	Add Object lblFreeware As Label With ;
		top=165, Left=15, FontSize=10, AutoSize=.t., ;
		Caption="Freeware (2008-2014)", ForeColor=rgb(128,64,0)
	Add Object cmdWebsite as MyCommandButton with ;
		top=150, Left=170, Width=240, FontSize=8, FontItalic=.t., ForeColor=rgb(128,64,0), ;
		Caption="http://sites.google.com/site/changmw"
	Add Object lblEmail As Label With ;
		top=190, Left=15, FontSize=10, AutoSize=.t., ForeColor=rgb(128,64,0), ;
		Caption="Programmed by Man-wai Chang"
	Add Object cmdEmail as MyCommandButton with ;
		top=180, Left=220, Width=190, FontSize=8, FontItalic=.t., ForeColor=rgb(128,64,0), ;
		Caption="Email: toylet.toylet@gmail.com"
	Add Object lblCopyRight As Label With ;
		top=215, Left=15, FontSize=10, AutoSize=.t., ForeColor=rgb(128,64,0), ;
		Caption="Powered by Micro$oft Visual Foxpro ";
				+iif(left(version(4),2)=="06"," 6 (SP5)","9 SP2")

	Function cmdEmail.Click()
		local m.lcTarget
		m.lcTarget = "mailto:toylet.toylet@gmail.com"+ ;
		  "?CC=&Subject= About Chang's Cantonese Input"+ ;
		   "&Body= "
		BrowseTo(m.lcTarget)
	return .t.

	Function cmdWebsite.Click()
		local m.lcTarget
		m.lcTarget = "https://sites.google.com/site/changmw/foxpro/cantonese-input"
		BrowseTo(m.lcTarget)
	return .t.
EndDefine

Define Class MyTextBox As TextBox
	FontSize=16
	Format="!K"
	lastvalue=""
	IntegralHeight=.t.
Enddefine

Define class MyUnicodeTextbox as OleControl 
*!*		http://www.foxite.com/archives/vfp-unicode-0000233480.htm
*!*
*!*		http://support.microsoft.com/kb/171673
*!*
*!*		Microsoft ActiveX Control Pad
*!*		http://msdn.microsoft.com/en-us/library/ms968493.aspx
		OleClass="Forms.TextBox.1"
		default_text=""

		procedure init
			this.multiline=.F.
			this.font.size=13
			this.IntegralHeight=.t.
			this.selectionmargin=.f.
			this.text=""
*!*			this.scrollbars=3
*!*			this.textAlign=3 
*!*			this.IMEmode=0 
			this.font.name="Courier New"
*!*			this.forecolor=rgb(0,0,255)*
*!*			=COMPROP(this,"UTF8",1)
		return .t.
EndDefine

Define class MyUnicodeLabel as OleControl
	OleClass="Forms.Label.1"
EndDefine

Define class MyLblContainer as Container
	height=50
	width=260
	BorderWidth=0
	BackColor=RGB(199,157,83)

	Add Object lblUncd As MyUnicodeLabel With ;
		top=3, Left=5, width=30, Height=25
	Add Object lblChangjei As MyLabel With ;
		top=5, Left=30, width=80, Height=25, ;
		ForeColor=RGB(32,128,32), ToolTipText="­Ü¾e½X"
	Add Object lblMatches As myLabel With ;
		top=3, Left=105, width=this.width-10-100, ;
		AutoSize=.f., Alignment=1
	Add Object lblCalculate As myLabel With ;
		top=25, Left=5, width=this.width-10, height=30, ;
		Autosize=.f., Alignment=1

	Procedure lblUncd.Init
		dodefault()
		this.font.size=12
		this.SpecialEffect=0
		this.BackColor=this.parent.BackColor
	return
EndDefine

Define class MyPage1 as MyPage
	caption="\<Main"
	my_top=5
	my_left=5

	Add Object text1 As MyTextbox With ;
		top=this.my_top+8,Left=this.my_left+5,Height=29, Width=110, ;
		FontName="Courier New", Format="@!",Value="", SelectOnEntry=.t.

	Add Object cmdClear as MyCommandButton with ;
		top=this.my_top+8,Left=this.my_left+5+110+5, ;
		Width=20,Caption="\<X", enable=.t.

	Add Object list1 As ListBox With ;
		top=this.my_top+50,Left=this.my_left+5,Width=140,Height=165, ;
		FontName="Courier New", FontSize=14, ;
		rowsourcetype=6, ;
		columncount=2, ;
		columnlines=.f., ;
		rowsource="left(matched.big5,4), kissed"

	Add Object edit1 As MyUnicodeTextBox With ;
		top=this.my_top+60,Left=this.my_left+150,Width=260,Height=120, ;
		TabStop=.F., ;
		ToolTipText="Enter a maths. equation here"

	Add Object cmdClip As MyCommandButton with ;
		top=this.my_top+185,Left=this.my_left+150, Width=75, Caption="\<Copy", enabled=.t.
	Add Object cmdHistory As MyCommandButton with ;
		top=this.my_top+185,Left=this.my_left+150+75+10, Width=75,Caption="\<History", enabled=.f.
	Add Object cmdReset As MyCommandButton With ;
		top=this.my_top+185,Left=this.my_left+150+75+75+20, Width=75,Caption="\<Reset", enabled=.t.

	Add Object CntLabels as MyLblContainer with ;
		top=this.my_top+3, left=this.my_left+150

*!*	form1.text1.Valid()
*!*	form1.command1.When()
*!*	form1.text1.LostFocus()
*!*	form1.command1.GotFocus()

	Function cmdClear.Click()
		with this.parent.text1
			.Value=""
			.InteractiveChange()
			.SetFocus()
		endwith
	return .t.

	Procedure text1.GotFocus
		with this.parent
			.cmdClear.WasHit=.f.
			.cmdClip.WasHit=.f.
			.cmdHistory.WasHit=.f.
			.cmdReset.WasHit=.f.
		endwith
	return

	Procedure text1.LostFocus
		with this.parent
		do case
			case reccount("matched")==0
				this.SelStart=0
				this.SelLength=len(alltrim(this.Value))
				nodefault
			case lastkey()=K_ENTER
				* first record match when exiting text1
				* preload the leaves to save an <ENTER>
				if matched.leaf=.f. and matched.big5=this.Value
					BuildMatched(this.Value)
				endif
		endcase
		endwith
	return

	Function text1.interactivechange()
	local m.xx
	m.xx=alltrim(this.Value)
	if empty(m.xx)
		with this.parent.CntLabels
			.lblCalculate.caption=""
			.lblMatches.caption=""
			.lblUncd.caption=""
			.lblChangjei.caption=""
		endwith
	endif
	if this.parent.edit1.text=this.parent.edit1.default_text
		this.parent.edit1.text=""
	endif
	select 0
	use (_screen.cantondbf) noupdate
	Select distinct thekey As big5, Space(1) As changjei, .F. As leaf , "" as kissed;
		from canton ;
		where (left(thekey,len(m.xx))=m.xx or empty(m.xx)) ;
		and !empty(thekey) ;
		into Cursor matched
	use in canton
	do case
		case reccount("matched")==0
			* no syllable match, search remap
			Select modified From remap ;
				where original=This.Value ;
				into Cursor t_dummy
			If !Empty(t_dummy.modified)
				This.Value=t_dummy.modified
			Endif
			Use In t_dummy
			BuildMatched(this.Value)
		case reccount("matched")==1
			* only one syllable found
			* preload leaves to save an <ENTER>
			BuildMatched(this.Value)
	endcase
	with this.parent
		.CntLabels.lblMatches.Caption=Alltrim(Str(Reccount("matched")))+" matches"
		with .list1
			.requery()
			.value=1
		endwith
	endwith
	return .t.

	Procedure edit1.init
		dodefault()
		* run "command /c echo "44CQ6L2J6LK844CR" | b64 -d | clip"
		this.multiline=.t.
		*
		* http://www.foxite.com/archives/vfp-unicode-0000233480.htm
		* this.text=strconv(STRCONV("rpt3gmlfcoJnUW5/b5g6eU9c",14),10)
		*
	EndProc

	Function edit1.LostFocus()
	local m.aa, m.errhand
	if !empty(this.text)
		m.aa=alltrim(this.text)
		m.aa=strtran(m.aa,space(1),"")
		m.aa=strtran(m.aa,chr(K_ENTER),"")
		m.aa=strtran(m.aa,chr(K_LF),"")

		m.errhand=on("error")
		on error *
		m.aa=eval(m.aa)
		on error &errhand

		with this.parent
			if type("m.aa")="N"
				if m.aa<>0
					.cntLabels.lblCalculate.caption=floatpnt(m.aa,15,4)
				endif
			else
				.cntLabels.lblCalculate.caption="Not an equation!!"
			endif
			.cmdReset.enabled=.t.
			.cmdClip.enabled=.t.
		endwith
	endif
	return .t.

	Function list1.DblClick()
		keyboard chr(K_ENTER)
		nodefault
	return .t.

	Procedure list1.KeyPress
	lparameter nKeyCode, nsac
	Local m.thekey, m.tempbuffer, m.xx
	with this.parent
		do case
			case nKeyCode=K_TAB
				.text1.SetFocus()
				nodefault
			case nkeycode=K_ENTER
				* ENTER
				If matched.leaf
					* leaf node, no need to drill further, user chose the chinese character
					thisform.addone(matched.big5)
					do case
						case thisform.PageFrame1.Page2.chkBig5Only.value
	 						m.xx=alltrim(matched.big5)
							.edit1.text=.edit1.text+m.xx
						case left(version(4),2)>"06"
							m.xx=strconv(alltrim(matched.uncd),14)
							.edit1.text=.edit1.text+m.xx
						otherwise
	 						m.xx=FromBase64(alltrim(matched.uncd))
							VFP6CopyUnicode(m.xx)
							.edit1.paste()
					endcase
					if thisform.PageFrame1.Page2.chkDirect.value
						pastebig5(alltrim(matched.big5))
					endif
					with thisform.PageFrame1.Page3.text21
	 					if left(version(4),2)>"06"
							.text=m.xx
						else
							.text=""
							.paste()
						endif
					endwith
					.cntLabels.lblUncd.caption=m.xx
					.cntLabels.lblChangjei.caption=":"+space(1)+matched.changjei
					.cmdReset.enabled=.t.
					.cmdClip.enabled=.t.
					.text1.SetFocus()
				Else
					* NOT leaf, load the chinese characters of the branch
					m.thekey=alltrim(matched.big5)
					with .text1
						.Value=m.thekey
						.lastValue=m.thekey
					endwith
					BuildMatched(m.thekey)
					.list1.Requery()
					.cntLabels.lblMatches.Caption=Alltrim(Str(Reccount("matched")))+" matches"
					.list1.Value=1
				Endif
				nodefault
		Endcase
	endwith
	Endproc

	Procedure cmdClip.Click
	local m.haha
	* copy to windows clipboard
	with this.parent
		if !empty(.edit1.text)
			with .edit1
				.selstart=0
				.sellength=len(.text)
				.copy()
			endwith
			thisform.buffer=thisform.buffer ;
				+iif(empty(thisform.buffer),"",CHR(K_LF)) ;
				+.edit1.text
			with this.parent
				.cmdHistory.enabled=!empty(thisform.buffer)
				.cmdReset.enabled=!empty(.edit1.text)
			endwith
		endif
		.text1.SetFocus()
	endwith
	Endproc

	Procedure cmdHistory.Click
	with this.parent
		.edit1.text=Thisform.buffer
		.cmdReset.enabled=!empty(.edit1.text)
		.cmdClip.enabled=!empty(.edit1.text)
		thisform.buffer=""
		this.enabled=.f.
		.text1.SetFocus()
	endwith
	Endproc

	Procedure cmdReset.Click
	local m.lastline, m.xx
	with this.parent
		m.xx=.edit1.text
		if thisform.lastclip()<>m.xx
			thisform.buffer=thisform.buffer ;
				+iif(empty(thisform.buffer),"",chr(K_ENTER)) ;
				+m.xx
		endif
		.edit1.text=""
		.cmdHistory.enabled=!empty(thisform.buffer)
		.cmdClip.enabled=!empty(.edit1.text)
		this.enabled=.f.
		.text1.SetFocus()
	endwith
	Endproc

	Procedure Activate
		dodefault()
		if _screen.FormInit
			this.text1.setfocus()
		endif
	Endproc
EndDefine

Function BuildMatched
LParameter m.thekey
	select 0
	use (_screen.cantondbf) noupdate alias canton
	if used("matched")
		use in matched
	endif
	Select big5, uncd, changjei,.T. As leaf, kissed_mask(touched) as kissed;
		from canton ;
		where thekey=m.thekey ;
		order by touched descending ;
		into Cursor matched
	use in canton
return .t.

Define class MyPage as Page
	fontsize=11
	WasHit=.f.

	Function Activate
		this.washit=.t.
		this.parent.refresh()
	return
Enddefine

Define class MyPageFrame as PageFrame 
	tabstyle=1
    top=5
    Left=5
    width=_screen.min_width-15
    height=_screen.min_height-10

	Add object Page1 as MyPage1
	Add object Page2 as MyPage2
	Add object Page3 as MyPage3
	Add object Page4 as MyPage4

	Procedure Refresh
		do case
			case this.ActivePage=1
				this.Page1.FontBold=.t.
				this.Page2.FontBold=.f.
				this.Page3.FontBold=.f.
				this.Page4.FontBold=.f.
			case this.ActivePage=2
				this.Page1.FontBold=.f.
				this.Page2.FontBold=.t.
				this.Page3.FontBold=.f.
				this.Page4.FontBold=.f.
			case this.ActivePage=3
				this.Page1.FontBold=.f.
				this.Page2.FontBold=.f.
				this.Page3.FontBold=.t.
				this.Page4.FontBold=.f.
			otherwise
				this.Page1.FontBold=.f.
				this.Page2.FontBold=.f.
				this.Page3.FontBold=.f.
				this.Page4.FontBold=.t.
		endcase
	return
	dodefault()
EndDefine

Define Class MyForm As Form
	icon="chang256.ico"
	ToolTipText=APP_NAME

	ShowWindow=2
	ShowTips=.t.
	AlwaysOnTop=.t.
	Desktop=.t.

	Caption=APP_NAME
	KeyPreview=.T.
	AutoCenter=.f.
	MaxButton=.f.
	Visible=.f.
	Width=_screen.min_width
	Height=_screen.min_height
	BorderStyle=1

	otoolbar=.F.
	Buffer=_cliptext

	* consider position of taskbar
	left=sysmetric(21)-_screen.min_width-15
	top=sysmetric(22)-_screen.min_height-45

	Add Object PageFrame1 as MyPageFrame

	Procedure Load
	Create Cursor remap ( vowel c(5), original c(10), modified c(10) )
	Thisform.makeremap()

	Select 0
	Use (_screen.cantondbf) noupdate
	Select distinct thekey As big5, Space(1) As changjei, .F. As leaf , "" as kissed;
		from canton ;
		where !empty(thekey) ;
		into Cursor matched
	use in canton
	Endproc

	Procedure Init
	local m.xx
	thisform.pageframe1.Page2.chkOnTop.Value=ThisForm.AlwaysOnTop
	select 0
	use (_screen.cantondbf) noupdate
	count to m.xx for !empty(thekey)
	use in canton
	with thisform.PageFrame1.Page1
		with .CntLabels
			.lblMatches.Caption=Alltrim(Str(m.xx))+" Words"
			* matched cursor pre-built by Form.Load()
			.lblCalculate.Caption=Alltrim(Str(reccount("matched")))+" Syllables"
		endwith
		.list1.Value=1
		.text1.setfocus()
	endwith
	_screen.FormInit=.t.
	with this.PageFrame1.Page1.edit1
		.paste()
		.default_text=.text
	endwith
	Endproc

	Procedure Activate
		* the reason to turn off _screen here is to ensure that
		* the form got focus when program started
		_Screen.Visible=.F.
	Endproc

	Procedure Unload
		if used("matched")
			Use In matched
		endif
		if used("remap")
			Use In remap
		endif
	Endproc

	Procedure KeyPress
	LParameters nkeycode, nsac
		If nkeycode=K_ESC
			Thisform.QueryUnload()
			Nodefault
		Endif
	return

	Procedure QueryUnload
	Local frmQuit, loParam

	if this.ReleaseType=2
		_screen.quit=.t.
		clear events
		thisform.release()
	else
		loParam=Createobject("MyParam")
		frmQuit=Createobject("MyFrmQuit",loParam)
		frmQuit.Show()
		Do Case
			Case loParam.toquit="N"
				nodefault
			Case loParam.toquit="X"
				_screen.quit=.T.
				Clear Events
				thisform.release()
			Case loParam.toquit="Y"
				Clear Events
				thisform.release()
		Endcase
	endif
	Endproc

	Procedure Destroy
		_Screen.Visible=.T.
	Endproc

	function lastclip
	local m.xx, m.errhand
	m.xx=mline(thisform.buffer,memlines(thisform.buffer))
	return m.xx

	function addone
	lparameter m.lcBig5
	local m.errhand
	m.errhand=on("error")
	on error *

	select 0
	use (_screen.cantondbf) shared
	locate for big5=m.lcBig5
	if found()
		select canton
		replace touched with touched+1
	endif
	use in canton

	on error &errhand
	return .t.


	Procedure makeremap
* missing: DEN, AI, TAG, TIM
	Insert Into remap Values ( "IU", "DIU", "DEW" )
	Insert Into remap Values ( "EONG", "CHEONG", "CHERN" )
	Insert Into remap Values ( "EUNG", "CHEUNG", "CHERN" )
	Insert Into remap Values ( "EUNG", "LEUNG", "LERN" )
	Insert Into remap Values ( "EUNG", "HEUNG", "HERN" )
	Insert Into remap Values ( "EUNG", "KEUNG", "KERN" )
	Insert Into remap Values ( "EUNG", "SHEUNG","SHERN" )
	Insert Into remap Values ( "EUNG", "TSEUNG","JUNK" )
	Insert Into remap Values ( "ANG",  "HANG", "HUNT" )
	Insert Into remap Values ( "EAN",  "DEAN", "DIN" )
	Insert Into remap Values ( "O",    "NGO", "ALL" )
	Insert Into remap Values ( "O",    "LO",  "NO" )		&& LOW, LAW
	Insert Into remap Values ( "O",    "SO",  "SOUL" )
	Insert Into remap Values ( "O",    "KO",  "GO" )
	Insert Into remap Values ( "O",    "HO",  "HALL" )
	Insert Into remap Values ( "O",    "WO",  "WALL" )
	Insert Into remap Values ( "O",    "MO",  "MODE" )
	Insert Into remap Values ( "IN",   "LIN", "LEAN" )
	Insert Into remap Values ( "IN",   "NIN", "LEAN" )
	Insert Into remap Values ( "IN",   "LIN", "LEAN" )
	Insert Into remap Values ( "IN",   "HIN", "HINT" )
	Insert Into remap Values ( "AN",   "SAM", "SUM" )
	Insert Into remap Values ( "AM",   "KAM", "GUM" )
	Insert Into remap Values ( "AM",   "NAM", "LARM" )
	Insert Into remap Values ( "AM",   "LAM", "LUMP" )		&& LUMP, LARM
	Insert Into remap Values ( "AU",   "LAU", "NULL" )		&& NULL, LOUD
	Insert Into remap Values ( "AU",   "SAU", "SHOUT" )
	Insert Into remap Values ( "AU",   "GAU", "COW" )
	Insert Into remap Values ( "AU",   "KAU", "CULT" )
	Insert Into remap Values ( "AU",   "NGAU", "OUT" )
	Insert Into remap Values ( "AU",   "CHAU", "CHOW" )
	Insert Into remap Values ( "AU",   "SHAU", "SHOUT" )
	Insert Into remap Values ( "AN",   "KWAN", "GROUND" )
	Insert Into remap Values ( "AN",   "MAN", "MUNK" )
	Insert Into remap Values ( "AN",   "SAN", "SARM" )		&& SARM, SAND
	Insert Into remap Values ( "AN",   "DAN", "DANT" )		&& DEN, DANT, DOWN
	Insert Into remap Values ( "ENG",  "SENG", "SUNK" )
	Insert Into remap Values ( "IN",   "HIN", "HINT" )
	Insert Into remap Values ( "IN",   "MIN", "MEAN" )
	Insert Into remap Values ( "IN",   "NIN", "LEAN" )
	Insert Into remap Values ( "IN",   "MUN", "MOON" )
	Insert Into remap Values ( "EE",   "MEE", "MEAN" )
	Insert Into remap Values ( "EE",   "LEE", "LAY" )
	Insert Into remap Values ( "ING",  "CHING", "CHAIN" )
	Insert Into remap Values ( "ING",  "NING", "LINK" )
	Insert Into remap Values ( "ING",  "LING", "LINK" )
	Insert Into remap Values ( "ING",  "MING", "MAIN" )
	Insert Into remap Values ( "ONG",  "KWONG", "GONE" )
	Insert Into remap Values ( "ONG",  "TONG", "TOM" )
	Insert Into remap Values ( "ONG",  "KONG", "GONE" )
	Insert Into remap Values ( "ON",   "BON", "BOMB" )
	Insert Into remap Values ( "ONG",  "BONG", "BOMB" )
	Insert Into remap Values ( "ONG",  "WONG", "WARM" )
	Insert Into remap Values ( "UN",   "KWUN", "KOON" )
	Insert Into remap Values ( "UN",   "NUN", "LUNG" )
	Insert Into remap Values ( "UK",   "LUK", "LOOK" )
	Insert Into remap Values ( "UK",   "KUK", "COOK" )
	Insert Into remap Values ( "UNG",  "CHUNG", "JONE" )		&& LUNG, LOAN
	Insert Into remap Values ( "UNG",  "SUNG", "ZONE" )
	Insert Into remap Values ( "UNG",  "KUNG", "CONE" )
	Insert Into remap Values ( "UNG",  "TUNG", "TONE" )		&& TONE, DONT
	Insert Into remap Values ( "UNG",  "FUNG", "PHONE" )
	Insert Into remap Values ( "OI",   "OI", "OIL" )
	Insert Into remap Values ( "OI",   "LOI", "LOY" )
	Insert Into remap Values ( "OI",   "SOI", "SOIL" )
	Insert Into remap Values ( "OI",   "KOI", "COIL" )
	Insert Into remap Values ( "OI",   "TSOI", "CHOI" )
	Insert Into remap Values ( "AAI",  "AI", "EYE" )
	Insert Into remap Values ( "AI",   "AI", "EYE" )
	Insert Into remap Values ( "AI",   "KWAI", "QUITE" )
	Insert Into remap Values ( "AI",   "DAI", "DIE" )
	Insert Into remap Values ( "AI",   "TAI", "TIE" )
	Insert Into remap Values ( "AI",   "WAI", "RIGHT" )
	Insert Into remap Values ( "AI",   "LAI", "LIKE" )		&& LIE, LIKE
	Insert Into remap Values ( "AI",   "SAI", "SITE" )
	Insert Into remap Values ( "AI",   "MAI", "MIND" )
	Insert Into remap Values ( "AI",   "KAI", "GUY" )
	Insert Into remap Values ( "AI",   "FAI", "FINE" )
	Insert Into remap Values ( "AI",   "HAI", "HIGH" )
	Insert Into remap Values ( "SI",   "SI", "SEE" )
	Insert Into remap Values ( "LI",   "LI", "LAY" )
	Insert Into remap Values ( "A",    "WA", "WAH" )
	Insert Into remap Values ( "IU",   "YIU", "YIELD" )
	Insert Into remap Values ( "IU",   "LIU", "NEW" )
	Insert Into remap Values ( "IU",   "SIU", "SILL" )
	Insert Into remap Values ( "IU",   "TIU", "TILL" )
	Insert Into remap Values ( "IU",   "KIU", "KILL" )
	Insert Into remap Values ( "IU",   "SHIU", "SILL" )
	Insert Into remap Values ( "IU",   "HIU", "HILL"  )
	Insert Into remap Values ( "IU",   "GIU", "GILL" )
	Insert Into remap Values ( "IU",   "MIU", "MILL" )
	Insert Into remap Values ( "IU",   "CHIU", "CHEW" )
	Insert Into remap Values ( "AO",   "TAO", "THOUGH" )
	Insert Into remap Values ( "AO",   "DAO", "THOUGH" )
	Insert Into remap Values ( "AO",   "MAO", "MODE" )
	Insert Into remap Values ( "A",    "TA", "TAR" )
	Insert Into remap Values ( "A",    "KA", "CAR" )
	Insert Into remap Values ( "A",    "CHA", "CHAR" )
	Insert Into remap Values ( "A",    "SA", "CZAR" )
	Insert Into remap Values ( "A",    "KWA", "GRA" )
	Insert Into remap Values ( "EI",   "LEI", "LAY" )
	Insert Into remap Values ( "EI",   "SEI", "SAY" )
	Insert Into remap Values ( "AK",   "TAK", "DUCK" )
	Insert Into remap Values ( "UE",   "YUE", "YU" )
	Insert Into remap Values ( "EH",   "YEH", "YEAH" )
	Insert Into remap Values ( "AAK",  "AAK", "ARK" )
	Insert Into remap Values ( "EUK",  "LEUK", "LURK" )
	Insert Into remap Values ( "IC",   "LIC", "LEG" )
	Insert Into remap Values ( "IC",   "VIC", "WAKE" )
	Endproc
Enddefine

Define Class MyFrmQuit As Form
	Caption="Quit"
	Height=90
	Width=150
	AutoCenter=.T.
	ControlBox=.F.
	BorderStyle=2
	** modal, in form
	WindowType=1
	ShowWindow=1
	oQuit=.F.

	Add Object btnYes As MyCommandButton With ;
		top=10,Left=20,Caption="\<Yes",ForeColor=RGB(255,0,0), ;
		Cancel=.T.
	Add Object btnNo As MyCommandButton With ;
		top=50,Left=20,Caption="\<No"
	Add Object btnReturn As MyCommandButton With ;
		top=90,Left=20,Caption="\<Back to VFP", ;
		ForeColor=RGB(255,128,0), visible=.f.

	Procedure btnNo.Click()
		Thisform.oQuit.toquit="N"
		This.parent.Release()
	Endproc

	Procedure btnYes.Click()
		* default thisform.oQuit.toquit is "X"
		This.parent.Release()
	Endproc

	Procedure btnReturn.Click()
		Thisform.oQuit.toQuit="Y"
		This.parent.Release()
	Endproc

	Procedure Init
	Lparameter loParam
		dodefault()
		This.oQuit=loParam
		This.oQuit.toquit="X"
		if _vfp.StartMode<>4
			This.Height=This.Height+40
			This.btnReturn.visible=.t.
		endif
	Endproc
Enddefine

Define Class myParam As Custom
	toquit="X"
Enddefine

Procedure makecantontxt
Clear All
Close All
Clear
Set Talk Off
Set Safety Off
Set Alternate To canton.txt
Set Alternate On
Select 0
Use (_screen.cantondbf) Noupdate
?? "/s a"
for m.ii=1 to 26
	locate for thekey="BIG"+chr(asc("A")+m.ii-1)
	?? canton.big5
endfor
? "MYNICK", "±i°O"
m.maxlen=0
Select Distinct thekey From canton ;
	where !Empty(thekey) ;
	into Cursor t_thekey
Scan
	If Len(Alltrim(thekey)) > m.maxlen
		m.maxlen=Len(Alltrim(thekey))
	Endif
	? Alltrim(thekey)
	Select canton
	Scan For thekey=t_thekey.thekey
		?? Space(1)+Alltrim(canton.big5)
	Endscan
Endscan
Use In t_thekey
Use In canton

Set Alternate Off
Set Alternate To

? "maximum length:",m.maxlen

Set Talk On
Set Safety On
Endproc

function cleancrlf
	lparameter m.xx
return strtran(strtran(m.xx,chr(K_ENTER),""),chr(K_LF),"")

function floatpnt
parameter m.in_prce, m.in_wid, m.in_dec
*
* copied from WAE's PROCEDR2.PRG
*
* m.in_prce = the floating point value
* m.in_wid  = the output width
* m.in_dec  = the maximum precision of m.in_prce
*
* 25/09/01 - MMC, created. beware of the limits...
*
* you can use the following to re-test this function
* set decimal to 5
* for m.ii=0 to 7
*   for m.jj=1 to 5
*     m.vv=10**m.ii+1/10**m.jj
*     ? m.ii, floatpnt(m.vv,7), floatpnt(-m.vv,7)
*   endfor
* endfor
*
private m.prce, m.wid, m.dec
private M.ss, m.xx, o_dec

if m.in_wid-m.in_dec<2
  * you need at least "0.", and "-" sign
  return "I CANT"
endif

o_dec=set("decimal")
set decimal to m.in_dec

m.dec=m.in_dec
m.prce=abs(m.in_prce)
m.wid=m.in_wid
if m.in_prce<0
  m.wid=m.wid-1
endif
if m.wid-m.dec<2
  * "0." has 2 places at least
  m.dec=m.dec-1
endif

m.ss=str(m.prce,15,m.dec)
if m.prce>10**(m.wid-1)
  * the recursive call here is pretty useless. but...
  m.ss=str(m.prce/1000,15)+"K"
else
  * check the width of the part before decimal point
  * trim the mantissa accordingly
  if m.prce<=1
    m.xx=m.dec
  else
    m.xx=m.wid-(int(log10(m.prce))+1)-1
    if m.xx<=0
      m.xx=0
    endif
  endif
  m.ss=str(m.prce,15,m.xx)
endif
m.ss=alltrim(right(m.ss,m.wid))
if m.in_prce<0
  m.ss="-"+m.ss
endif
* removing trailing decimal zero
if "."$m.ss
  do while right(m.ss,1)="0"
    m.ss=left(m.ss,len(m.ss)-1)
  enddo
  if right(m.ss,1)="."
    m.ss=left(m.ss,len(m.ss)-1)
  endif
  if val(m.ss)=0
    m.ss="0"
  endif
endif
set decimal to &o_dec
return padl(m.ss,m.in_wid)

function kissed_mask
lparameter m.touched
local m.xx
if m.touched>9999
	m.touched=9999
endif
if m.touched=0
	m.xx=""
else
	m.xx=str(m.touched,5)
endif
return padr(m.xx,6)

function BrowseTo
lparameter m.lcTarget
local m.lcMail
DECLARE INTEGER ShellExecute ;
	    IN SHELL32.DLL ;
	    INTEGER nWinHandle,;
	    STRING cOperation,;
	    STRING cFileName,;
	    STRING cParameters,;
	    STRING cDirectory,;
	    INTEGER nShowWindow
ShellExecute(0,"open",m.lcTarget,"","",1)
clear dlls ShellExecute
return .t.

FUNCTION FirstInstance(pMutex)    && pMutex=Program name
local m.ok

   DECLARE INTEGER CreateMutex IN WIN32API INTEGER, INTEGER, STRING @
   DECLARE INTEGER CloseHandle IN WIN32API INTEGER
   DECLARE INTEGER GetLastError IN WIN32API
   _screen.MutexHandle=CreateMutex(0, 1, @pMutex)
   m.ok=(GetLastError() <> ERROR_MUTEX_EXISTS)
   clear dlls "CreateMutex", "CloseHandle", "GetLastError"
   return  m.ok
ENDFUNC

FUNCTION CloseMutex
  DECLARE INTEGER ReleaseMutex IN kernel32 INTEGER hMutex
  DECLARE INTEGER CloseHandle IN WIN32API INTEGER
  ReleaseMutex(_screen.MutexHandle)  
  CloseHandle(_screen.MutexHandle)
  clear dlls ReleaseMutex, CloseHandle
endproc

FUNCTION getGUID()
local cGUID, cBuffer, nBufsize, m.reply
	* reference:
	* http://fox.wikis.com/wc.dll?Wiki~ControllingTheNumberOfApplicationInstances

	DECLARE INTEGER CoCreateGuid IN ole32 STRING @pguid
	DECLARE INTEGER StringFromGUID2 IN ole32;
		STRING rguid, STRING @lpsz, INTEGER cchMax

	m.reply=""
	cGUID = REPLICATE(CHR(0), 16)  && 128 bits
	if  CoCreateGuid(@cGUID)=0
		nBufsize=128
		cBuffer = REPLICATE(CHR(0), nBufsize*2)
		= StringFromGUID2(cGUID, @cBuffer, nBufsize)
		cBuffer = SUBSTR(cBuffer, 1, AT(CHR(0)+CHR(0), cBuffer))
		m.reply=STRCONV(cBuffer, 6)
	endif

	clear dlls CoCreateGuid, StringFromGUID2
RETURN m.reply

function pastebig5
lparameter m.inchar
*
* http://vcpptips.wordpress.com/tag/getwindowthreadprocessid/
* http://www.news2news.com/vfp/?function=390
* http://www.news2news.com/vfp/?example=371&function=392
*
*
LOCAL cBuffer, m.haha, m.ii
LOCAL lnThreaddId, ln_my_window, ln_current_window, ln_window_count, lc_window_title

	DECLARE INTEGER GetActiveWindow ;
	   IN win32api
	DECLARE INTEGER GetWindow ;
	   IN win32api ;
	   INTEGER ncurr_window_handle, ;
	   INTEGER ndirection
    DECLARE INTEGER GetWindowText IN user32;
            INTEGER hwnd, STRING @lpString, INTEGER cch    
	DECLARE LONG IsWindowVisible IN "user32" LONG HWND

	DECLARE INTEGER SetForegroundWindow ;
		IN user32 ;
		INTEGER hwnd

	DECLARE INTEGER BlockInput IN user32 INTEGER fBlockIt
	DECLARE SHORT VkKeyScan IN user32;
	    INTEGER ch
	DECLARE keybd_event IN user32;
	    SHORT bVk,;
	    SHORT bScan,;
	    INTEGER dwFlags,;
	    INTEGER dwExtraInfo
	DECLARE Sleep IN kernel32 INTEGER dwMilliseconds

	DECLARE INTEGER SendMessage IN user32 ;
	    INTEGER hWnd,;
	    INTEGER Msg,;
	    INTEGER wParam,;
	    INTEGER lParam
	DECLARE SHORT PostMessage IN user32;
	    INTEGER   hWnd,;
	    INTEGER   Msg,;
	    INTEGER   wParam,;
	    INTEGER   lParam
	DECLARE SHORT PostMessageW IN user32;
	    INTEGER   hWnd,;
	    INTEGER   Msg,;
	    INTEGER   wParam,;
	    INTEGER   lParam

	DECLARE INTEGER GetWindowThreadProcessId IN user32;
	    INTEGER   hWnd,;
	    INTEGER @ lpdwProcId
    DECLARE INTEGER GetGUIThreadInfo IN user32;
        INTEGER idThread, STRING @lpgui

    DECLARE INTEGER GetLastError IN kernel32

	DECLARE INTEGER GetClassName IN user32;
	    INTEGER   hWnd,;
	    STRING  @ lpClassName,;
	    INTEGER   nMaxCount

#ifdef debug_caret
set console off
set alternate to z:\debug.txt
set alternate on
#endif

ln_my_window=GetActiveWindow()
ln_current_window=ln_my_window
ln_window_count=0
DO WHILE ln_current_window>0
	lc_window_title=GetWindowCaption(ln_current_window)
	#ifdef debug_caret
	? "window", ln_window_count, ": ", ln_current_window, lc_window_title
	#endif
	IF !EMPTY(lc_window_title)
		do case
			case upper(lc_window_title)="START"
			case IsWindowVisible(ln_current_window) = 0
			otherwise
				ln_window_count=ln_window_count+1
				if ln_window_count=2
					* got the previous window in z-order
					BlockInput(1)
					SetForegroundWindow(ln_current_window)
					Sleep(20)
					lnThreadId=GetWindowThreadProcessId(ln_current_window, 0)
					#ifdef debug_caret
						? "window", ln_current_window, "thread", lnThreadId
					#endif
					cBuffer = Chr(GUITHREADINFO_SIZE) + Repli(Chr(0), GUITHREADINFO_SIZE-1)
	 				IF GetGUIThreadInfo(lnThreadId, @cBuffer) = 0
	 				   messagebox("GetGUIThreadInfo() Error: "+GetLastError(),16)
					ELSE
						m.haha = wnd(cBuffer, 13, "Window that has the keyboard focus")
						#ifdef debug_caret
						? "cBuffer", transform(cBuffer, "@0"), m.haha
						#endif
						do case					
							case m.haha>0
								#ifdef debug_caret
								? "using postmessage()"
								#endif
								for m.ii=1 to len(m.inchar)
									PostMessage(m.haha, WM_CHAR, asc(substr(m.inchar,m.ii,1)), 0)
								endfor
							case .f.
								* PASTE using clipboard
								CopyUnicodeText2Clipboard(strconv(m.inchar,12))
								if .t.
									#ifdef debug_caret
									? "using wm_paste"
									#endif
									PostMessage(ln_current_window, WM_PASTE, 0, 0)
								else
									* send big5 by keybd_event()
									#ifdef debug_caret
									? "using keybd_event(big5)"
									#endif
									sendkey(asc(left(m.inchar,1)), 0)
									sendkey(asc(left(m.inchar,1)), KEYEVENTF_KEYUP)
									sendkey(asc(right(m.inchar,1)), 0)
									sendkey(asc(right(m.inchar,1)), KEYEVENTF_KEYUP)
								endif
							otherwise
								#ifdef debug_caret
								? "using keybd_event(control+v)"
								#endif
								_cliptext=m.inchar
								* send CONTROL+V by keybd_event()
								sendkey(VK_CONTROL, 0)
								sendkey(asc("V"), 0)
								sendkey(asc("V"), KEYEVENTF_KEYUP)
								sendkey(VK_CONTROL, KEYEVENTF_KEYUP)
	 					endcase
					ENDIF
					SetForegroundWindow(ln_my_window)
					BlockInput(0)
					exit
				endif
		endcase
	ENDIF
	ln_current_window=GetWindow(ln_current_window,GW_HWNDNEXT)
ENDDO

clear dlls

#ifdef debug_caret
set alternate off
set alternate to
set console on
#endif
return

function sendkey
lparameter m.vk, m.flag
	keybd_event(m.vk, 0, m.flag, 0)
	Sleep(20)
return

*
*|typedef struct tagGUITHREADINFO {
*|    DWORD cbSize;       0:4
*|    DWORD flags;        4:4
*|    HWND hwndActive;    8:4
*|    HWND hwndFocus;     12:4
*|    HWND hwndCapture;   16:4
*|    HWND hwndMenuOwner; 20:4
*|    HWND hwndMoveSize;  24:4
*|    HWND hwndCaret;     28:4
*|    RECT rcCaret;       32:16
*|} GUITHREADINFO, *PGUITHREADINFO; total 48 bytes
*

function wnd
lparameter cBuffer, lnOffs, lcTitle
local hWindow, lcCaption
    hWindow = buf2dword(SUBSTR(cBuffer, lnOffs,4))
    lcCaption = GetWindowCaption(hWindow)
#ifdef debug_caret
=ins(lcTitle, LTRIM(STR(hWindow)) + ", [" + GetClsName(hWindow) + "]")
#endif    
return hWindow
 
PROCEDURE ins(cTitle, cValue)
	? m.cTitle, m.cValue
RETURN

FUNCTION buf2dword(lcBuffer)
RETURN Asc(SUBSTR(lcBuffer, 1,1)) + ;
    BitLShift(Asc(SUBSTR(lcBuffer, 2,1)),  8) +;
    BitLShift(Asc(SUBSTR(lcBuffer, 3,1)), 16) +;
    BitLShift(Asc(SUBSTR(lcBuffer, 4,1)), 24)
 
FUNCTION GetWindowCaption(lnWindow)
LOCAL lnLength, lcText
    lcText = SPACE(250)
    lnLength = GetWindowText(lnWindow, @lcText, Len(lcText))
RETURN iif(lnLength>0, Left(lcText, lnLength), space(1))

Function GetClsName
lParameter ln_current_window
local cBuffer, nBufSize
cBuffer = Repli(Chr(0), 250)
nBufsize = GetClassName(ln_current_window, @cBuffer, Len(cBuffer))
return SUBSTR(cBuffer, 1, nBufsize)

*
* http://fox.wikis.com/wc.dll?Wiki~UniCode
* 
PROCEDURE UnicodeToString( pcStr )
  LOCAL lcSkel
  lcSkel = StrConv( pcStr,  6 ) && Double Byte <- Unicode
  lcSkel = StrConv( lcSkel, 2 ) && Single byte <- Double Byte
  RETURN LEFT(lcSkel, MAX(AT(chr(0),lcSkel)-1,0) )
ENDPROC
PROCEDURE StringToUnicode( pcStr )
  LOCAL lcSkel
  lcSkel = StrConv( pcStr,  1 ) && Single byte -> Double Byte
  lcSkel = StrConv( lcSkel, 5 ) && Double Byte -> Unicode
  RETURN lcSkel+chr(0)
ENDPROC

*
* http://www.berezniker.com/content/pages/visual-foxpro/copy-unicode-text-clipboard
*
* Copy Unicode text into Clipboard
FUNCTION CopyUnicodeText2Clipboard(tcUnicodeText)
LOCAL lnDataLen, lcDropFiles, llOk, i, lhMem, lnPtr, lcUnicodeText
#DEFINE CF_UNICODETEXT  13
 
*  Global Memory Variables with Compile Time Constants
#DEFINE GMEM_MOVABLE 	0x0002
#DEFINE GMEM_ZEROINIT	0x0040
#DEFINE GMEM_SHARE		0x2000
 
* Load required Windows API functions
*  Clipboard Functions
DECLARE LONG OpenClipboard IN WIN32API LONG HWND
DECLARE LONG CloseClipboard IN WIN32API
DECLARE LONG EmptyClipboard IN WIN32API
DECLARE LONG SetClipboardData IN WIN32API LONG uFormat, LONG hMem
*  Memory Management Functions
DECLARE LONG GlobalAlloc IN WIN32API LONG wFlags, LONG dwBytes
DECLARE LONG GlobalFree IN WIN32API LONG HMEM
DECLARE LONG GlobalLock IN WIN32API LONG HMEM
DECLARE LONG GlobalUnlock IN WIN32API LONG HMEM
DECLARE LONG RtlMoveMemory IN WIN32API As CopyFromStr LONG lpDest, String @lpSrc, LONG iLen
 
llOk = .T.
lcUnicodeText = tcUnicodeText + CHR(0)+CHR(0)
lnDataLen = LEN(lcUnicodeText)
* Copy Unicode text into the allocated memory
lhMem = GlobalAlloc(GMEM_MOVABLE+GMEM_ZEROINIT+GMEM_SHARE, lnDataLen)
lnPtr = GlobalLock(lhMem)
=CopyFromStr(lnPtr, @lcUnicodeText, lnDataLen)
=GlobalUnlock(lhMem)
* Open clipboard and store Unicode text into it
llOk = (OpenClipboard(0) <> 0)
IF llOk
	=EmptyClipboard()
	llOk = (SetClipboardData(CF_UNICODETEXT, lhMem) <> 0)
	* If call to SetClipboardData() is successful, the system will take ownership of the memory
	*   otherwise we have to free it
	IF NOT llOk
		=GlobalFree(lhMem)
	ENDIF
	* Close clipboard
	=CloseClipboard()
ENDIF
clear dlls OpenClipboard, CloseClipboard, EmptyClipboard, SetClipboardData
clear dlls GlobalAlloc, GlobalFree, GlobalLock, GlobalUnlock, RtlMoveMemory
RETURN llOk

*
* http://blogs.lessthandot.com/index.php/datamgmt/datadesign/displaying-and-saving-unicode-data/
*
*!*	In the form¡¦s Load we need the following:
*!*	Sys(987,.F.)
*!*	Sys(3101,65001)
*!*	Then, after getting binary data from SQL Server the same way as I show in this blog, 
*!*   we still need to use createbinary, e.g.
*!*	this.txtLanguage.text = createbinary(prefs_sl.Language00)
*!*	We don¡¦t want to use COMPROP now for the ActiveX.
*!*	and then, saving data, we need to follow Rick¡¦s steps:
*!*	pcSavedText1 = Strconv(This.Text,12)
*!*	*** Must explicitly force to binary ¡V can also use CAST in 9.0
*!*	pcSavedText1 = CREATEBINARY(pcSavedText1)

Procedure recode
*!* 5	Converts double-byte characters to UNICODE (wide characters)
*!* 6	Converts UNICODE (wide characters) to double-byte characters.
*!*
*!*	9	Converts double-byte characters in cExpression to UTF-8
*!*	11	Converts UTF-8 characters in cExpression to double-byte characters.
*!*
*!*	10	Converts Unicode characters in cExpression to UTF-8
*!*	12	Converts UTF-8 characters in cExpression to UNICODE characters.
*!*
*!* 13	Converts single-byte characters in cExpression to encoded base64 binary.
*!* 14	Converts base64 encoded data in cExpression to original unencoded data.
*
close all
clear all
sys(3101,65001)
select 0
use (_screen.cantondbf) shared
scan
	replace uncd with strconv(strconv(big5,9),13)
endscan
close all
clear all
return

*
* http://www.news2news.com/vfp/?example=88
*
FUNCTION ToBase64(cSrc)
    LOCAL nFlags, nBufsize, cDst
    nFlags=CRYPT_STRING_BASE64

    DECLARE INTEGER CryptBinaryToString IN Crypt32;
        STRING @pbBinary, LONG cbBinary, LONG dwFlags,;
        STRING @pszString, LONG @pcchString
 
    DECLARE INTEGER CryptStringToBinary IN crypt32;
        STRING @pszString, LONG cchString, LONG dwFlags,;
        STRING @pbBinary, LONG @pcbBinary,;
        LONG pdwSkip, LONG pdwFlags 
    nBufsize=0
    = CryptBinaryToString(@cSrc, LEN(cSrc),;
        m.nFlags, NULL, @nBufsize)
     cDst = REPLICATE(CHR(0), m.nBufsize)
    IF CryptBinaryToString(@cSrc, LEN(cSrc), m.nFlags,;
        @cDst, @nBufsize) = 0
        RETURN ""
    ENDIF

    clear dlls
RETURN cDst

FUNCTION FromBase64(cSrc)
    LOCAL nFlags, nBufsize, cDst
    nFlags=CRYPT_STRING_BASE64

    DECLARE INTEGER CryptBinaryToString IN Crypt32;
        STRING @pbBinary, LONG cbBinary, LONG dwFlags,;
        STRING @pszString, LONG @pcchString
 
    DECLARE INTEGER CryptStringToBinary IN crypt32;
        STRING @pszString, LONG cchString, LONG dwFlags,;
        STRING @pbBinary, LONG @pcbBinary,;
        LONG pdwSkip, LONG pdwFlags
 
    nBufsize=0
    = CryptStringToBinary(@cSrc, LEN(m.cSrc),;
        nFlags, NULL, @nBufsize, 0,0)
 
    cDst = REPLICATE(CHR(0), m.nBufsize)
    IF CryptStringToBinary(@cSrc, LEN(m.cSrc),;
        nFlags, @cDst, @nBufsize, 0,0) = 0
        RETURN ""
    ENDIF
    clear dlls
RETURN m.cDst
 

FUNCTION tbsave
   *
   * save the settings
   *
   PUBLIC ARRAY gaTBSets[12, 2]
   *
   LOCAL lnCntr
   *
   *-- Fill an array with toolbar names.
   *
   gaTBSets[ 1, 1] = "Color Palette"
   gaTBSets[ 2, 1] = "Database Designer"
   gaTBSets[ 3, 1] = "Form Controls"
   gaTBSets[ 4, 1] = "Form designer"
   gaTBSets[ 5, 1] = "Layout"
   gaTBSets[ 6, 1] = "Print Preview"
   gaTBSets[ 7, 1] = "Query Designer"
   gaTBSets[ 8, 1] = "Report Controls"
   gaTBSets[ 9, 1] = "Report Designer"
   gaTBSets[10, 1] = "Standard"
   gaTBSets[11, 1] = "View Designer"
   gaTBSets[12, 1] = "Properties"
   *
   *-- Check toolbars for their visibility
   *-- If so, store that setting in the 2nd column.
   *-- and hide the toolbar
   *
   _SCREEN.LOCKSCREEN = .T.
   FOR lnCntr = 1 TO ALEN(gaTBSets,1)
      IF WEXIST( gaTBSets[lnCntr,1] )
         gaTBSets[ lnCntr,2 ] = .T.
         HIDE WINDOW (gaTBSets[lnCntr,1])
      ELSE
         gaTBSets[ lnCntr,2 ] = .F.
      ENDIF
   ENDFOR
   _SCREEN.LOCKSCREEN = .F.
   *
ENDFUNC

FUNCTION TBRest
   *
   *-- Make the toolbars visible that are stored as previously visible in the gaTBSets array
   *
   LOCAL lnCntr
   *
   _SCREEN.LOCKSCREEN = .T.
   FOR lnCntr = 1 TO ALEN( gaTBSets ,1 )
      IF gaTBSets[ lnCntr, 2 ]
         SHOW WINDOW ( gaTBSets[ lnCntr, 1 ] )
      ENDIF
   ENDFOR
   _SCREEN.LOCKSCREEN = .F.
ENDFUNC

******************************
Function readcanton
If File(_screen.cantondbf)
	messagebox("CANTON.DBF already existed! Rename it.",16)
	Return .F.
Endif
Create Table canton ( thekey c(10), big5 c(2) )
Create Cursor temp ( Aline c(80) )
Append From canton.txt Type Sdf
Select temp
m.maxlen=0
Scan
	If Recno() > 2
		xx=At(" ",temp.Aline)
		kk=Left(temp.Aline,xx)
		If !Empty(m.kk)
			If Len(m.kk) > m.maxlen
				m.maxlen=Len(m.kk)
			Endif
			big5=Alltrim(Substr(temp.Aline,xx,xx+20))
			Insert Into canton Values (kk, m.big5)
		Endif
	Endif
Endscan
? "max key length=",m.maxlen
? "word count=",Reccount("canton")
Close All
Return .T.

Procedure readoldcanton
Select 0
Use (_screen.cantondbf) Shared
Select 0
Use ophrase Shared
Scan
	Replace ophrase.Found With Space(1)
	Select canton
	Locate For big5=ophrase.Code
	If Found()
		Replace canton.canton With ophrase.Sound
	Else
		Insert Into canton ( ;
			big5, canton ;
			) Values ( ;
			ophrase.Code, ophrase.Sound ;
			)
	Endif
Endscan
Use In canton
Use In ophrase
Endproc

Procedure readchangjei
Select 0
Use (_screen.cantondbf) Shared
Create Cursor t_changjei ( ;
	filler c(4),;
	big5 c(2),;
	radical c(3),;
	stroke c(3),;
	changjei c(10),;
	found c(1);
	)
Append From changjei.txt Delimited With Tab
Scan
	Select canton
	Locate For big5=t_changjei.big5
	If Found()
		Select canton
		Replace changjei With t_changjei.changjei
	Else
		Insert Into canton ( ;
			big5, changjei ;
			) Values ( ;
			t_changjei.big5,t_changjei.changjei ;
			)
	Endif
Endscan
Select t_changjei
Brow For Empty(t_changjei.Found)
Use In t_changjei
Use In canton
Endproc

procedure readhkscs2008
set talk off
set exact on

clear all
close all
local m.raw, m.ii, m.jj, m.yy, m.xx, m.kk, m.raw1, m.raw2

clear

set console on
set alternate to cj.txt
set alternate on

select 0
use data\canton shared

m.xx=fopen("Z:\aroot\Visual FoxPro Projects\canton\tables\CJ-HKSCS-2008.txt")
do while !feof(m.xx)
	m.yy=fgets(m.xx)
	m.ii=at("=",m.yy)
	if m.ii > 0
		m.changjei=left(m.yy,m.ii-1)
		m.raw=right(m.yy, len(m.yy)-m.ii)
		do while len(m.raw)>=3
			m.raw1=left(m.raw,3)
			checkdb(m.raw1, m.changjei)
			* remove ","
			m.raw=substr(m.raw,5,len(m.raw)-4)
		enddo
	endif
enddo
fclose(m.xx)
use

set alternate off
set alternate to
set console on

close all
clear all

set exact off
set talk on
return

function checkdb
lparameter m.raw, m.changjei
local m.uncd, m.big5
	m.uncd=strconv(m.raw,13)
	m.big5=strconv(m.raw,11)
	select canton
	locate for uncd=m.uncd
	if found()
		select canton
		if empty(canton.thekey)
			replace thekey with "UNICODE"
		endif
		if empty(canton.changjei) or canton.changjei<>m.changjei
			replace changjei with m.changjei
		endif
	else
		m.thekey=""
		if "?"$m.big5
			m.thekey="UNICODE"
		endif
		insert into canton ( ;
			uncd, big5, thekey, changjei ;
		) values ( ;
			m.uncd, m.big5, m.thekey, m.changjei ;
		)
	endif
return .t.

Function UniqueFname
lParameter m.suffix
* Using sys(3) will need some delay between each call
if empty(m.suffix)
	m.suffix="tmp"
endif
return sys(2023)+"\"+SUBSTR(SYS(2015), 3, 10)+"."+m.suffix

function MySleep
lParameter m.msec
local m.xx
	DECLARE Sleep IN kernel32 INTEGER dwMilliseconds
	m.xx=sleep(m.msec)
	clear dlls
return m.xx

Function VFP6CopyUnicode
lParameter m.utf8
local nResult
strtofile(m.utf8, _screen.txtname)
nResult = LaunchExeAndWait(_screen.clipbatname,sys(2023),"HIDE")
return nResult

Function VFP6EncodeUTF8
local nResult
nResult = LaunchExeAndWait(_screen.encdbatname,sys(2023),"HIDE")
return left(filetostr(_screen.outname),4)

FUNCTION LaunchExeAndWait
LPARAMETERS pcCommandLine, puFromDir, pcWindowMode
*
* Source: 
* https://social.msdn.microsoft.com/Forums/en-US/9f663558-56ab-4bda-9d4c-2f966979356c/shellexecute-to-launch-vfp-app-from-another-vfp-app?forum=visualfoxprogeneral
* http://fox.wikis.com/wc.dll?Wiki~ProcessExitCode
*
*	pcCommandLine			(R) - command line to launch
*	puFromDir				(O) - Run from directory (default - CWD)
*	pcWindowMode			(O)	- Start Application Window mode, one of (HIDE, MIN, MAX, NOR)
*								  (default - default setting of application)

*	Returns:
*	0 = CreateProcess didn't start what was asked
*	1 = Process ran to completion
*	-1= Process started but user aborted wait.  Danger - app is still running AFAIK

#DEFINE cnINFINITE 		0xFFFFFFFF
#DEFINE cnPollKeyboard	5			&& milliseconds
#DEFINE cnTimedOut		0x0102

*	We need some API calls, declare here

*	GetCurrentProcess() returns the pseudohandle of the current process
DECLARE INTEGER GetCurrentProcess IN WIN32API AS GetCurrProc

*	WaitForIdleInput() waits until the target process is idle for input
DECLARE INTEGER WaitForInputIdle IN WIN32API AS WaitInpIdle ;
	INTEGER nProcessHandle, ;
	INTEGER nWaitForDuration

*	WaitForSingleObject() waits until the handle in parm 1 is signalled 
*	or the timeout period expires
DECLARE INTEGER WaitForSingleObject IN WIN32API AS WaitOnAppExit ;
	INTEGER hProcessHandle, ;
	INTEGER dwTimeOut

DECLARE INTEGER GetExitCodeProcess in win32api ;
  INTEGER hProcess, INTEGER @ nExitCode

*	This API call does the work.  The parameters are as follows:
*		lpszModuleName - ptr-> file name of module to execute.  Since we aren't launching .CPLs, do not use
*		lpszCommandLine - ptr-> command to execute, as passed to us
*		lpSecurityAttributesProcess - ptr-> SECURITY_ATTRIBUTES structure for Process.  Pass a null pointer
*		lpSecurityAttributesThread - ptr-> SECURITY_ATTRIBUTES structure for first thread.  Pass a null pointer
*		bInheritHandles - whether or not chlid inherits parent handles.  Since no SECURITY_ATTRIBUTES passed, default to FALSE
*		dwCreateFlags - Process Creation Mode flag set.  We use the default mode at normal priority, ie 0
*		lpvEnvironment	- ptr-> a set of environment strings as if a MULTI_SZ.  We don't set, so pass a null pointer
*		lpszStartupDir - ptr-> the starting directory.  If none provided to us, pass a null pointer
*		lpStartInfo - ptr-> a STARTUPINFO structure.  We use one structure member at times.
*		lpProcessInfo - ptr-> a PROCESS_INFORMATION structure, used to return PID/PHANDLE detail.  
*						We use one member on return
DECLARE SHORT CreateProcess IN WIN32API AS CrPr ;
	STRING lpszModuleName, ;
	STRING @lpszCommandLine, ;
	STRING lpSecurityAttributesProcess, ;
	STRING lpSecurityAttributesThread, ;
	SHORT bInheritHandles, ;
	INTEGER dwCreateFlags, ;
	STRING lpvEnvironment, ;
	STRING lpszStartupDir, ;
	STRING @lpStartInfo, ;
	STRING @lpProcessInfo

IF TYPE('pcCommandLine') # 'C'
	*	Command line must be a character string
	RETURN 0
ENDIF

IF TYPE('puFromDir') # 'C'
	*	If not a character string, pass a null pointer, defaulting to Current Working Dir
	puFromDir = 0
ELSE
	*	Otherwise, null pad the string
	puFromDir = puFromDir + CHR(0)
ENDIF

IF TYPE('pcWindowMode') # 'C'
	*	If not passed, set to null string
	pcWindowMode = ''
ELSE
	*	Translate the passed window mode to uppercase
	pcWindowMode = UPPER(pcWindowMode)
ENDIF

LOCAL nStartedProcessHandle, uResult, cProcessInfo, cStartUpInfo

*	Make default Structures for the CreateProcess call
*
*	ProcessInfo - 4 bytes, a Process handle, a Thread Handle, a (DWORD) ProcessId and a (DWORD) ThreadID
*					we save the Process handle and return it to caller in tnReturnProcessHandle

cProcessInfo = REPL(CHR(0),16)

*	StartUpInfo is a 68 byte long complex structure;  we either have 68 bytes with a cb member (byte 1) 68
*	or with cb of 68, dwFlag low order byte (byte 45) of 1, and low order byte wShowWindow (byte 49) set to
*	the SW_ value appropriate for the Window Mode desired.

DO CASE
CASE pcWindowMode = 'HIDE'

	*	Hide - use STARTF_USESHOWFLAG and value of 0
	cStartUpInfo = CHR(68) + ;
					REPL(CHR(0),43) + ;
					CHR(1) + ;
					REPL(CHR(0),23)

CASE pcWindowMode = 'NOR'

	*	Normal - use STARTF_USESHOWFLAG and value of 1
	cStartUpInfo = CHR(68) + ;
					REPL(CHR(0),43) + ;
					CHR(1) + ;
					REPL(CHR(0),3) + ;
					CHR(1) + ;
					REPL(CHR(0),19)

CASE pcWindowMode = 'MIN'

	*	Minimize - use STARTF_USESHOWFLAG and value of 2
	cStartUpInfo = CHR(68) + ;
					REPL(CHR(0),43) + ;
					CHR(1) +  ;
					REPL(CHR(0),3) + ;
					CHR(2) + ;
					REPL(CHR(0),19)

CASE pcWindowMode = 'MAX'

	*	Maximize - use STARTF_USESHOWFLAG and value of 3
	cStartUpInfo = CHR(68) + ;
					REPL(CHR(0),43) + ;
					CHR(1) +  ;
					REPL(CHR(0),3) + ;
					CHR(3) + ;
					REPL(CHR(0),19)
					
*	Other options exist - see WINBASE.H for values
OTHERWISE

	*	Use default of application
	cStartUpInfo = CHR(68) + REPL(CHR(0),67)

ENDCASE

*	Do it now!
uResult = CrPr(	0, ;
				pcCommandLine, ;
				0, 0, 0, 0, 0, ;
				puFromDir, ;
				@cStartUpInfo, ;
				@cProcessInfo)
IF uResult > 0
	*	CreateProcess() started our app, but we have to wait until it finishes loading
	*	Strip the process handle from the PROCESS_INFORMATION structure
	nStartedProcessHandle = (((ASC(SUBST(cProcessInfo,4,1))*256) + ;
								ASC(SUBST(cProcessInfo,3,1)))*256 + ;
								ASC(SUBST(cProcessInfo,2,1)))*256 + ;
								ASC(LEFT(cProcessInfo,1))
	*	It's been launched;  wait until we're idling along
	=WaitInpIdle(GetCurrProc(),cnINFINITE)
	*	As long as the other process exists, wait for it
	DO WHILE WaitOnAppExit(nStartedProcessHandle, cnPollKeyboard) = cnTimedOut
		*	Give us an out in case the other app hangs - lets the user quit via <Esc>
		IF INKEY() = K_ESC
			*	Still running but we aren't waiting - return a -1 as a warning
			uResult = -1
			EXIT
		ENDIF
	ENDDO
ENDIF
clear dlls
RETURN uResult